This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    deploy.yml
.repomix/
  bundles.json
bot/
  handlers.py
services/
  downloader.py
  file_manager.py
.gitignore
.music_botOLD
config.py
main.py
README.md
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomix/bundles.json">
{
  "bundles": {
    "repomixMusicBot-325": {
      "name": "repomixMusicBot",
      "created": "2025-08-25T12:10:15.936Z",
      "lastUsed": "2025-08-25T12:10:15.936Z",
      "tags": [],
      "files": []
    }
  }
}
</file>

<file path="services/file_manager.py">
from pathlib import Path
from typing import Optional
import os
import logging

logger = logging.getLogger(__name__)

class FileManager:
    @staticmethod
    def safe_remove(file_path: Optional[Path]):
        if file_path and file_path.exists():
            try:
                os.unlink(file_path)
                logger.info(f"–£–¥–∞–ª—ë–Ω —Ñ–∞–π–ª: {file_path}")
            except OSError as e:
                logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª {file_path}: {e}")

    @staticmethod
    def get_file_size_mb(file_path: Path) -> float:
        return file_path.stat().st_size / (1024 * 1024)
</file>

<file path=".gitignore">
.env
__pycache__/
*.pyc
Qobuz_Downloads/
bot.log
venv/
</file>

<file path=".music_botOLD">
import os
import logging
import asyncio
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters
from dotenv import load_dotenv
from subprocess import Popen, PIPE
from uuid import uuid4
from threading import Lock

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN")

# –ü—É—Ç–∏
VENV_PYTHON = "/opt/qobuz-env/bin/python"
QOBUZ_DL = "/opt/qobuz-env/bin/qobuz-dl"
DOWNLOAD_DIR = "/root/musicBot/Qobuz/Downloads"
os.makedirs(DOWNLOAD_DIR, exist_ok=True)

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

# –û—á–µ—Ä–µ–¥—å –∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞
download_queue = asyncio.Queue()
download_lock = Lock()

# –ö–æ–º–∞–Ω–¥–∞ /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üéµ –ü—Ä–∏–≤–µ—Ç! –û—Ç–ø—Ä–∞–≤—å —Å—Å—ã–ª–∫—É –Ω–∞ —Ç—Ä–µ–∫ Qobuz –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã /download")

# –ö–æ–º–∞–Ω–¥–∞ /download
async def download_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üìé –û—Ç–ø—Ä–∞–≤—å —Å—Å—ã–ª–∫—É –Ω–∞ —Ç—Ä–µ–∫ Qobuz –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º")

# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
async def handle_link(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    if "qobuz.com/track/" in text:
        await download_queue.put((update, context, text))
        await update.message.reply_text("‚è≥ –¢—Ä–µ–∫ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –æ—á–µ—Ä–µ–¥—å –∑–∞–≥—Ä—É–∑–∫–∏... üåÄ")
    else:
        await update.message.reply_text("‚ùå –≠—Ç–æ –Ω–µ —Å—Å—ã–ª–∫–∞ –Ω–∞ —Ç—Ä–µ–∫ Qobuz!")

# –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫ –∞—É–¥–∏–æ—Ñ–∞–π–ª–æ–≤
def find_audio_files(directory):
    found_files = []
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith((".flac", ".mp3")):
                full_path = os.path.join(root, file)
                logger.info(f"üîç –ù–∞–π–¥–µ–Ω —Ñ–∞–π–ª: {full_path}")
                found_files.append(full_path)
    return found_files

# –í–æ—Ä–∫–µ—Ä –∑–∞–≥—Ä—É–∑–∫–∏
async def download_worker():
    while True:
        update, context, url = await download_queue.get()
        chat_id = update.effective_chat.id

        try:
            temp_id = uuid4().hex
            logger.info(f"üîª –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É: {url}")
            await context.bot.send_message(chat_id, f"üöÄ –ù–∞—á–∏–Ω–∞—é –∑–∞–≥—Ä—É–∑–∫—É —Ç—Ä–µ–∫–∞:\n{url}")

            # –ü–µ—Ä–µ—Ö–æ–¥ –≤ –ø–∞–ø–∫—É –∑–∞–≥—Ä—É–∑–∫–∏
            os.chdir(DOWNLOAD_DIR)

            # –ö–æ–º–∞–Ω–¥–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å –ø–æ–Ω–∏–∂–µ–Ω–Ω—ã–º –∫–∞—á–µ—Å—Ç–≤–æ–º
            command = [
                QOBUZ_DL, "dl", url,
                "--no-db",
                "--quality", "6"
            ]
            process = Popen(command, stdout=PIPE, stderr=PIPE)
            stdout, stderr = process.communicate()

            stdout_decoded = stdout.decode().strip()
            stderr_decoded = stderr.decode().strip()

            if stdout_decoded:
                logger.info(stdout_decoded)
            if stderr_decoded:
                if "Error" in stderr_decoded or "Exception" in stderr_decoded:
                    logger.error(stderr_decoded)
                else:
                    logger.info(stderr_decoded)

            # –ü–æ–∏—Å–∫ –∞—É–¥–∏–æ—Ñ–∞–π–ª–æ–≤
            downloaded_files = find_audio_files(DOWNLOAD_DIR)
            if not downloaded_files:
                await context.bot.send_message(chat_id, "‚ùå –ó–∞–≥—Ä—É–∑–∫–∞ –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ.")
                continue

            track_file = downloaded_files[0]
            cover_file = os.path.join(os.path.dirname(track_file), "cover.jpg")
            cover_file = cover_file if os.path.exists(cover_file) else None

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞
            file_size = os.path.getsize(track_file)
            size_mb = round(file_size / 1024 / 1024, 2)

            try:
                if file_size <= 50 * 1024 * 1024:
                    logger.info(f"üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç—Ä–µ–∫–∞ –∫–∞–∫ audio ({size_mb} MB)")
                    await context.bot.send_audio(chat_id=chat_id, audio=open(track_file, "rb"))
                elif file_size <= 2 * 1024 * 1024 * 1024:
                    logger.info(f"üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç—Ä–µ–∫–∞ –∫–∞–∫ document ({size_mb} MB)")
                    await context.bot.send_document(chat_id=chat_id, document=open(track_file, "rb"), filename=os.path.basename(track_file))
                else:
                    await context.bot.send_message(chat_id, "‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —á–µ—Ä–µ–∑ Telegram (> 2 –ì–ë).")
                    logger.warning(f"‚ùó –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π: {track_file} ({size_mb} MB)")
                    continue
            except Exception as send_err:
                logger.exception("üö´ –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–∞")
                await context.bot.send_message(chat_id, "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–∞–π–ª. –í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –∏–ª–∏ Telegram –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.")

            if cover_file:
                await context.bot.send_photo(chat_id=chat_id, photo=open(cover_file, "rb"))

            # –£–¥–∞–ª–µ–Ω–∏–µ
            os.remove(track_file)
            if cover_file:
                os.remove(cover_file)

            await context.bot.send_message(chat_id, "‚úÖ –ì–æ—Ç–æ–≤–æ! –¢—Ä–µ–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∏ —É–¥–∞–ª—ë–Ω —Å —Å–µ—Ä–≤–µ—Ä–∞.")

        except Exception as e:
            logger.exception("‚ùó –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ç—Ä–µ–∫–∞")
            await context.bot.send_message(chat_id, f"‚ùó –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ: {str(e)}")

        finally:
            download_queue.task_done()

# –û—Å–Ω–æ–≤–Ω–æ–π –∑–∞–ø—É—Å–∫
if __name__ == "__main__":
    logger.info("üöÄ KuzyMusicBot –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")

    application = Application.builder().token(BOT_TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("download", download_command))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_link))

    async def on_startup(app):
        asyncio.create_task(download_worker())
        logger.info("ü§ñ KuzyMusicBot –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ")

    application.post_init = on_startup
    application.run_polling()
</file>

<file path="config.py">
from pathlib import Path
from dotenv import load_dotenv
import os

load_dotenv()

class Config:
    BOT_TOKEN = os.getenv("BOT_TOKEN")
    # –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    QOBUZ_LOGIN = os.getenv("QOBUZ_LOGIN")
    QOBUZ_PASSWORD = os.getenv("QOBUZ_PASSWORD")
    
    DOWNLOAD_DIR = Path("/root/musicBot/Qobuz/Downloads")
    MAX_FILE_SIZE_MB = 2000
    LOG_FILE = Path("logs/bot.log")
</file>

<file path="requirements.txt">
anyio==4.9.0
beautifulsoup4==4.13.4
certifi==2025.7.9
charset-normalizer==3.4.2
colorama==0.4.6
h11==0.14.0
httpcore==1.0.9
httpx==0.25.2
idna==3.10
mutagen==1.47.0
pathvalidate==3.3.1
pick==1.6.0
python-telegram-bot==20.7
qobuz-dl==0.9.9.10
requests==2.32.4
sniffio==1.3.1
soupsieve==2.7
tqdm==4.67.1
typing_extensions==4.14.1
urllib3==2.5.0
python-dotenv
pydub
</file>

<file path="main.py">
import logging
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters
from bot.handlers import start, help_command, handle_download
from config import Config
from dotenv import load_dotenv

def setup_logging():
    # –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è –ª–æ–≥–æ–≤ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    Config.LOG_FILE.parent.mkdir(exist_ok=True)
    
    logging.basicConfig(
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        level=logging.INFO,
        handlers=[
            logging.FileHandler(Config.LOG_FILE, mode="a"),
            logging.StreamHandler()
        ]
    )
    # –ü–æ–Ω–∏–∂–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è "–±–æ–ª—Ç–ª–∏–≤—ã—Ö" –±–∏–±–ª–∏–æ—Ç–µ–∫, —á—Ç–æ–±—ã —Å–∫—Ä—ã—Ç—å —Ç–æ–∫–µ–Ω
    logging.getLogger("httpx").setLevel(logging.WARNING)
    logging.getLogger("telegram.ext").setLevel(logging.WARNING)

def main():
    load_dotenv()
    setup_logging()
    app = ApplicationBuilder().token(Config.BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("download", handle_download))
    
    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è —Å—Å—ã–ª–æ–∫, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –±–µ–∑ –∫–æ–º–∞–Ω–¥—ã
    app.add_handler(MessageHandler(
        filters.TEXT & ~filters.COMMAND & filters.Regex(r"qobuz\.com/track/"), 
        handle_download
    ))

    app.run_polling()

if __name__ == "__main__":
    main()
</file>

<file path=".github/workflows/deploy.yml">
name: üöÄ Deploy to VPS

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout repo
        uses: actions/checkout@v3

      - name: üöÄ Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: root
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            # --- –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ ---
            APP_DIR="/root/musicBot"
            REPO_URL="https://github.com/kuzyivan/musicBot.git"

            # --- –ü–µ—Ä–µ—Ö–æ–¥ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–¥–∞ ---
            echo "üìÅ –ü–µ—Ä–µ—Ö–æ–¥ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø—Ä–æ–µ–∫—Ç–∞..."
            mkdir -p "$APP_DIR"
            cd "$APP_DIR"

            echo "üîß –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è..."
            if [ ! -d .git ]; then
              git clone "$REPO_URL" .
            else
              git pull origin main
            fi

            # --- –°–æ–∑–¥–∞–Ω–∏–µ .env —Ñ–∞–π–ª–∞ –∏–∑ —Å–µ–∫—Ä–µ—Ç–æ–≤ GitHub ---
            echo "ü§´ –°–æ–∑–¥–∞–Ω–∏–µ .env —Ñ–∞–π–ª–∞ –∏–∑ —Å–µ–∫—Ä–µ—Ç–æ–≤..."
            echo "BOT_TOKEN=${{ secrets.BOT_TOKEN }}" > .env
            echo "QOBUZ_LOGIN=${{ secrets.QOBUZ_LOGIN }}" >> .env
            echo "QOBUZ_PASSWORD=${{ secrets.QOBUZ_PASSWORD }}" >> .env
            echo "‚úÖ .env —Ñ–∞–π–ª —Å–æ–∑–¥–∞–Ω."

            # --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –æ–∫—Ä—É–∂–µ–Ω–∏—è Python ---
            echo "üêç –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –æ–∫—Ä—É–∂–µ–Ω–∏—è..."
            if [ ! -d "venv" ]; then
              echo "–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ venv..."
              python3 -m venv venv
            fi
            source venv/bin/activate

            # --- –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π ---
            echo "üì¶ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π..."
            pip install --upgrade pip
            pip install -r requirements.txt

            # --- –°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π ---
            echo "üìÅ –°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π –¥–ª—è –ª–æ–≥–æ–≤ –∏ –∑–∞–≥—Ä—É–∑–æ–∫..."
            mkdir -p logs
            mkdir -p Qobuz/Downloads

            # --- –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–∞ ---
            echo "‚ôªÔ∏è –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–∞ musicbot..."
            systemctl daemon-reload
            systemctl restart musicbot.service

            echo "‚úÖ –†–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!"
</file>

<file path="bot/handlers.py">
from telegram import Update
from telegram.ext import ContextTypes
from services.downloader import QobuzDownloader
from services.file_manager import FileManager
from config import Config
import logging
import re
import subprocess
from pathlib import Path

logger = logging.getLogger(__name__)

# --- –§—É–Ω–∫—Ü–∏—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ ---
def convert_to_mp3(file_path: Path) -> Path:
    mp3_path = file_path.with_suffix(".mp3")
    logger.info(f"–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Ñ–∞–π–ª–∞ {file_path} –≤ MP3...")
    try:
        subprocess.run(
            ["ffmpeg", "-i", str(file_path), "-b:a", "320k", "-vn", str(mp3_path)],
            check=True, capture_output=True,
        )
        logger.info(f"–§–∞–π–ª —É—Å–ø–µ—à–Ω–æ —Å–∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –≤ {mp3_path}")
        return mp3_path
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ ffmpeg: {e}")
        return None

# --- –°–ª–æ–≤–∞—Ä—å –∫–∞—á–µ—Å—Ç–≤ ---
QUALITY_HIERARCHY = {
    "HI-RES (24-bit < 96kHz)": 7,
    "CD (16-bit)": 6,
    "MP3 (320 kbps)": 5,
}

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üéµ –ü—Ä–∏–≤–µ—Ç! –Ø –º–æ–≥—É —Å–∫–∞—á–∏–≤–∞—Ç—å —Ç—Ä–µ–∫–∏ —Å Qobuz.")

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("/start ‚Äî –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ\n/download <—Å—Å—ã–ª–∫–∞> ‚Äî —Å–∫–∞—á–∞—Ç—å —Ç—Ä–µ–∫")

async def handle_download(update: Update, context: ContextTypes.DEFAULT_TYPE):
    url = context.args[0] if context.args else getattr(getattr(update, 'message', None), 'text', '').strip()
    if not url:
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ —Ç—Ä–µ–∫.")
        return

    chat_id = update.effective_chat.id
    if not re.match(r"https?://(www\.|open\.|play\.)?qobuz\.com/(.+)", url):
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É –Ω–∞ —Ç—Ä–µ–∫ Qobuz.")
        return

    downloader = QobuzDownloader()
    file_manager = FileManager()
    
    audio_file_to_send = None
    cover_file_to_send = None
    files_to_delete = set()

    try:
        sent_message = await update.message.reply_text("‚è≥ –ù–∞—á–∏–Ω–∞—é –ø–æ–∏—Å–∫...")
        
        # --- –ì–∏–±—Ä–∏–¥–Ω–∞—è –ª–æ–≥–∏–∫–∞: —Å–Ω–∞—á–∞–ª–∞ –ø–æ–Ω–∏–∂–µ–Ω–∏–µ –∫–∞—á–µ—Å—Ç–≤–∞, –ø–æ—Ç–æ–º –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è ---
        for i, (quality_name, quality_id) in enumerate(QUALITY_HIERARCHY.items()):
            await context.bot.edit_message_text(
                chat_id=chat_id, message_id=sent_message.message_id,
                text=f"üíø –ü—Ä–æ–±—É—é —Å–∫–∞—á–∞—Ç—å –≤ –∫–∞—á–µ—Å—Ç–≤–µ: {quality_name}..."
            )
            
            audio_file, cover_file = await downloader.download_track(url, quality_id)
            if cover_file: files_to_delete.add(cover_file)

            if not audio_file:
                logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –≤ –∫–∞—á–µ—Å—Ç–≤–µ {quality_name}.")
                continue

            files_to_delete.add(audio_file)
            size_mb = file_manager.get_file_size_mb(audio_file)
            
            if size_mb <= 48:
                logger.info(f"–§–∞–π–ª –ø–æ–¥—Ö–æ–¥–∏—Ç –ø–æ —Ä–∞–∑–º–µ—Ä—É ({size_mb:.2f} MB).")
                audio_file_to_send = audio_file
                cover_file_to_send = cover_file
                break
            else:
                logger.warning(f"–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π ({size_mb:.2f} MB).")
                # –ï—Å–ª–∏ —ç—Ç–æ –ø–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–ø—ã—Ç–∫–∞ –∏ —Ñ–∞–π–ª –≤—Å–µ –µ—â–µ –±–æ–ª—å—à–æ–π - –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º
                is_last_attempt = (i == len(QUALITY_HIERARCHY) - 1)
                if is_last_attempt:
                    await context.bot.edit_message_text(
                        chat_id=chat_id, message_id=sent_message.message_id,
                        text=f"üéß –§–∞–π–ª –≤—Å–µ –µ—â–µ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π ({size_mb:.2f} MB). –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É—é –≤ MP3..."
                    )
                    converted_file = convert_to_mp3(audio_file)
                    if converted_file:
                        files_to_delete.add(converted_file)
                        audio_file_to_send = converted_file
                        cover_file_to_send = cover_file
                    break # –í—ã—Ö–æ–¥–∏–º –∏–∑ —Ü–∏–∫–ª–∞ –ø–æ—Å–ª–µ –ø–æ–ø—ã—Ç–∫–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏

        if not audio_file_to_send:
            await context.bot.edit_message_text(
                chat_id=chat_id, message_id=sent_message.message_id, 
                text="‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª. –í–æ–∑–º–æ–∂–Ω–æ, —Ç—Ä–µ–∫ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π."
            )
            return

        await context.bot.edit_message_text(
            chat_id=chat_id, message_id=sent_message.message_id,
            text="üì§ –§–∞–π–ª –≥–æ—Ç–æ–≤, –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ Telegram..."
        )

        original_name = Path(str(audio_file_to_send).replace(".mp3", ".flac")).name # –ë–µ—Ä–µ–º –∏–º—è –æ—Ç –∏—Å—Ö–æ–¥–Ω–∏–∫–∞
        album_folder = audio_file_to_send.parent.name
        match = re.match(r"(?P<artist>.+?) - (?P<album>.+?) \((?P<year>\d{4})", album_folder)
        artist, album, year = match.groups() if match else ("Unknown", "Unknown", "0000")

        track_title = re.sub(r"^\d+\.\s*", "", original_name.rsplit(".", 1)[0])
        ext = audio_file_to_send.suffix
        custom_filename = f"{artist.strip()} - {track_title.strip()} ({album.strip()}, {year.strip()}){ext}"
        
        with open(audio_file_to_send, 'rb') as f:
            await context.bot.send_audio(chat_id, f, filename=custom_filename)

        if cover_file_to_send:
            with open(cover_file_to_send, 'rb') as img:
                await context.bot.send_photo(chat_id, img)
        
        await context.bot.delete_message(chat_id, sent_message.message_id)

    except Exception as e:
        logger.exception("–û–±—â–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞")
        await update.message.reply_text(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e}")
    finally:
        logger.info("–û—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤...")
        for file_to_delete in files_to_delete:
            file_manager.safe_remove(file_to_delete)
        logger.info("–í—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã —É–¥–∞–ª–µ–Ω—ã.")
</file>

<file path="README.md">
# üéµ KuzyMusicBot

**Telegram-–±–æ—Ç –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ç—Ä–µ–∫–æ–≤ —Å Qobuz**

## ‚öôÔ∏è –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏

- –°–∫–∞—á–∏–≤–∞–µ—Ç —Ç—Ä–µ–∫–∏ –ø–æ —Å—Å—ã–ª–∫–µ —Å [Qobuz](https://www.qobuz.com/)
- –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∞—É–¥–∏–æ—Ñ–∞–π–ª –∏ –æ–±–ª–æ–∂–∫—É
- –£–¥–∞–ª—è–µ—Ç —Ñ–∞–π–ª—ã –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏
- –õ–æ–≥–∏—Ä—É–µ—Ç –¥–µ–π—Å—Ç–≤–∏—è –≤ —Ñ–∞–π–ª –∏ Telegram-—á–∞—Ç –∞–¥–º–∏–Ω–∞

## üöÄ –£—Å—Ç–∞–Ω–æ–≤–∫–∞

```bash
git clone https://github.com/kuzyivan/musicBot.git
cd musicBot
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
cp .env.example .env  # –∏ –∑–∞–ø–æ–ª–Ω–∏ –∑–Ω–∞—á–µ–Ω–∏—è
</file>

<file path="services/downloader.py">
from pathlib import Path
from typing import Optional, Tuple
from config import Config
import logging
import os
from qobuz_dl.core import QobuzDL

logger = logging.getLogger(__name__)

class QobuzDownloader:
    def __init__(self):
        self.download_dir = Config.DOWNLOAD_DIR
        self.download_dir.mkdir(parents=True, exist_ok=True)
        
        self.client = QobuzDL()
        try:
            logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ Qobuz...")
            self.client.get_tokens()
            self.client.initialize_client(
                Config.QOBUZ_LOGIN,
                Config.QOBUZ_PASSWORD,
                self.client.app_id,
                self.client.secrets
            )
            logger.info("–ö–ª–∏–µ–Ω—Ç Qobuz —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.")
        except Exception as e:
            logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∫–ª–∏–µ–Ω—Ç Qobuz!")
            self.client = None

    async def download_track(self, url: str, quality_id: int) -> Tuple[Optional[Path], Optional[Path]]:
        if not self.client:
            logger.error("–ö–ª–∏–µ–Ω—Ç Qobuz –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω. –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ.")
            return None, None
            
        original_dir = Path.cwd()
        try:
            logger.info(f"–ó–∞–ø—É—Å–∫ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –¥–ª—è URL: {url} —Å –∫–∞—á–µ—Å—Ç–≤–æ–º ID: {quality_id}")
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∂–µ–ª–∞–µ–º–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –∏ –æ—Ç–∫–ª—é—á–∞–µ–º –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ —á–µ—Ä–µ–∑ —Å–≤–æ–π—Å—Ç–≤–∞ –∫–ª–∏–µ–Ω—Ç–∞
            self.client.limit_quality = quality_id
            self.client.no_db = True
            
            os.chdir(self.download_dir)
            
            # –í—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é handle_url –¢–û–õ–¨–ö–û —Å–æ —Å—Å—ã–ª–∫–æ–π
            self.client.handle_url(url)

            audio_file, cover_file = self._find_downloaded_files()
            if audio_file:
                logger.info(f"–ù–∞–π–¥–µ–Ω —Å–∫–∞—á–∞–Ω–Ω—ã–π —Ñ–∞–π–ª: {audio_file}")
            else:
                logger.warning("–°–∫–∞—á–∞–Ω–Ω—ã–π –∞—É–¥–∏–æ—Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            
            return audio_file, cover_file
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ —á–µ—Ä–µ–∑ –º–æ–¥—É–ª—å qobuz-dl: {e}")
            logger.exception("Traceback –æ—à–∏–±–∫–∏:")
            return None, None
        finally:
            os.chdir(original_dir)

    def _find_downloaded_files(self) -> Tuple[Optional[Path], Optional[Path]]:
        for f in Path(".").glob("**/*.*"):
            if f.is_file() and f.suffix in {".flac", ".mp3", ".m4a", ".wav"}:
                audio_file = self.download_dir / f
                cover_file = self.download_dir / f.parent / "cover.jpg"
                return audio_file, cover_file if cover_file.exists() else None
        return None, None
</file>

</files>
